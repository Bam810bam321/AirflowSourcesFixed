#include "exploits.h"

#include "../../base/sdk.h"
#include "../../base/sdk/entity.h"
#include "../../base/sdk/c_usercmd.h"

#include "../../base/global_context.h"

#include "../../base/tools/threads.h"

#include "../features.h"
#include "../config_vars.h"

#include "../visuals/event/event_logger.h"

#include "../../base/hooks/hooks.h"

void call_createmove_features( c_usercmd* cmd )
{
  auto old_cmd = g_ctx.cmd;
  g_ctx.cmd = cmd;

  g_ctx.update_local_player( );

  g_ctx.base_angle = cmd->viewangles;
  g_ctx.orig_angle = cmd->viewangles;

  g_ctx.lagcomp = cvars::cl_lagcompensation->get_int( );
  g_ctx.lerp_time = g_animation_fix->get_lerp_time( );

  if( g_ctx.in_game )
  {
    auto netchannel = interfaces::engine->get_net_channel_info( );
    if( netchannel )
    {
      if( !netchannel->is_loopback( ) )
        g_ctx.real_ping = netchannel->get_latency( flow_outgoing );
      else
        g_ctx.real_ping = -1.f;

      g_ctx.ping = netchannel->get_latency( flow_incoming ) + netchannel->get_latency( flow_outgoing );
    }
  }
  else
    g_ctx.real_ping = -1.f;

  g_utils->clantag( );
  if( g_ctx.local && g_ctx.local->is_alive( ) )
  {
    g_ctx.sidemove = cmd->sidemove;
    g_ctx.forwardmove = cmd->forwardmove;

    // predict ticbase on low fps
    // https://github.com/rollraw/qo0-base/blob/master/base/features/prediction.cpp#L172
    g_ctx.tick_base = [ & ]( )
    {
      static int tick_base = 0;

      if( cmd != nullptr )
      {
        static c_usercmd* last_cmd = nullptr;

        // if command was not predicted - increment tickbase
        if( last_cmd == nullptr || last_cmd->predicted )
          tick_base = g_ctx.local->tickbase( );
        else
          tick_base++;

        last_cmd = cmd;
      }

      return tick_base;
    }( );

    if( g_ctx.weapon )
    {
      if( g_ctx.weapon->is_grenade( ) )
        g_ctx.predicted_curtime = math::ticks_to_time( g_ctx.tick_base );
      else
        g_ctx.predicted_curtime = math::ticks_to_time( g_ctx.tick_base - g_exploits->tickbase_offset( ) );

      g_ctx.abs_origin = g_ctx.local->get_abs_origin( );

      g_utils->on_pre_predict( );

      auto old_angle = cmd->viewangles;

      g_anti_aim->on_pre_predict( );
      g_movement->on_pre_predict( );

      g_ctx.modify_eye_pos = true;

      g_rage_bot->start_stop( );

      g_engine_prediction->start( g_ctx.local, g_ctx.cmd );
      {
        g_movement->on_predict_start( );

        g_movement->jitter_move( );
        g_movement->auto_strafe( );
        g_ctx.eye_position = g_ctx.local->origin( ) + g_ctx.local->view_offset( );

        cmd->viewangles = old_angle;

        g_fake_lag->on_predict_start( );
        g_anti_aim->on_predict_start( );
        g_anti_aim->on_predict_end( );
        g_utils->on_predict_start( );
        g_engine_prediction->predicted_buttons = g_ctx.cmd->buttons;
      }
      g_engine_prediction->finish( g_ctx.local );

      g_utils->on_predict_end( );

      if( *g_ctx.send_packet )
        g_ctx.sent_tick_count = interfaces::global_vars->tick_count;

      g_ctx.modify_eye_pos = false;
    }
  }

  bool fix_pitch = true;

  cmd->viewangles = math::normalize( cmd->viewangles, fix_pitch );
  cmd->forwardmove = std::clamp( cmd->forwardmove, -450.f, 450.f );
  cmd->sidemove = std::clamp( cmd->sidemove, -450.f, 450.f );
  cmd->upmove = std::clamp( cmd->upmove, -320.f, 320.f );

  g_ctx.cmd = old_cmd;
}

void shift_fake_cmds( c_usercmd* current_cmd, c_usercmd* first_cmd, int amount, bool silent = false )
{
  // alloc empty cmds
  std::vector< c_usercmd > fake_cmds;
  fake_cmds.resize( amount );

  // create fake commands & simulate their movement
  for( int i = 0; i < amount; ++i )
  {
    auto cmd = &fake_cmds [ i ];
    if( cmd != first_cmd )
      std::memcpy( cmd, first_cmd, sizeof( c_usercmd ) );

    // disable in-game simulation for this cmd
    cmd->predicted = true;

    if( !silent )
    {
      // simulate cmd manually
      // also do movement & other important shit
      call_createmove_features( cmd );

      cmd->buttons &= ~( in_attack | in_attack2 );
    }
    else
      // don't add cmd to prediction & simulation record
      cmd->tickcount = INT_MAX;
  }

  // shift cmds
  auto net_chan = interfaces::client_state->net_channel_ptr;
  if( !net_chan )
    return;

  auto net_channel_info = interfaces::engine->get_net_channel_info( );

  auto command_number = current_cmd->command_number + 1;
  auto add_command_number = current_cmd->command_number + 1;
  for( int i = 0; i < fake_cmds.size( ); ++i )
  {
    // just ghetto cuz i had cl move before
    if( !silent )
      g_exploits->cl_move.shift = g_exploits->cl_move.shifting = true;

    auto fake_cmd = &fake_cmds [ i ];
    auto new_cmd = interfaces::input->get_user_cmd( command_number );

    if( new_cmd != fake_cmd )
      memcpy( new_cmd, fake_cmd, sizeof( c_usercmd ) );

    new_cmd->command_number = command_number;
    new_cmd->predicted = true;

    // don't add cmd to prediction & simulation record
    if( silent )
      new_cmd->tickcount = INT_MAX;

    auto verified_cmd = interfaces::input->get_verified_user_cmd( command_number );
    auto verfied_cmd_ptr = &verified_cmd->cmd;

    if( verfied_cmd_ptr != new_cmd )
      memcpy( verified_cmd, new_cmd, sizeof( c_usercmd ) );

    verified_cmd->crc = new_cmd->get_check_sum( );

    if( !silent )
    {
      // for silent shift you don't need to index every fake command you send
      ++net_chan->choked_packets;
      ++net_chan->out_sequence_nr;
    }

    ++interfaces::client_state->choked_commands;

    command_number = add_command_number + 1;
    ++add_command_number;
  }

  g_exploits->cl_move.shift = g_exploits->cl_move.shifting = false;

  if( !silent )
  {
    interfaces::prediction->reset_predict( );

    *g_ctx.send_packet = true;
  }

  fake_cmds.clear( );
}

void c_tickbase::store( int tickbase, int cmd, int shift, bool restore, int cmd_diff )
{
  this->data.tickbase = tickbase;
  this->data.command_number = cmd;
  this->data.shift_amount = shift;
  this->data.restore_tickbase = restore;
  this->data.cmd_diff = cmd_diff;
}

void c_tickbase::fix( int new_command_number, int& tickbase )
{
  auto& d = this->data;
  if( d.command_number <= 0 )
    return;

  auto viewmodel = g_ctx.local->get_view_model( );
  if( !viewmodel )
    return;

  if( d.command_number == new_command_number )
  {
    viewmodel->anim_time( ) -= math::ticks_to_time( d.shift_amount + interfaces::global_vars->sim_ticks_this_frame );

    tickbase = d.tickbase - d.shift_amount + interfaces::global_vars->sim_ticks_this_frame;
  }

  if( d.restore_tickbase && d.command_number + d.cmd_diff == new_command_number )
  {
    viewmodel->anim_time( ) += math::ticks_to_time( d.shift_amount - interfaces::global_vars->sim_ticks_this_frame );

    tickbase += d.shift_amount - interfaces::global_vars->sim_ticks_this_frame;
  }
}

void write_user_cmd( void* buf, c_usercmd* in, c_usercmd* out )
{
  __asm {
        mov     ecx, buf
        mov     edx, in
        push    out
        call    func_ptrs::write_user_cmd
        add     esp, 4
    }
}

bool c_exploits::should_shift_cmd( int* new_commands, int* backup_commands, void* ecx, int slot, void* buf, int from, int to )
{
  static auto original = vtables [ vtables_t::client ].original< write_usercmd_fn >( xor_int( 24 ) );
  return original( ecx, slot, buf, from, to, true );
}

void c_exploits::force_shift( c_usercmd* cmd, int amount, bool buffer )
{
  if( charge_ticks < amount )
    return;

  if( !stop_movement )
    stop_movement = true;

  if( teleport && !teleportshift )
    teleportshift = true;

  shift_tick = g_ctx.cmd->command_number;

  cl_move.shift = true;
  cl_move.amount = amount - 1;
}

bool c_exploits::recharging( c_usercmd* cmd )
{
  if( cmd->weaponselect )
    return false;

  static int last_choke = 0;
  if( recharge && !last_choke )
  {
    if( ++charge_ticks >= amounts.recharge )
    {
      recharge = false;
      recharge_finish = true;
      stop_movement = true;
    }

    shift = 0;

    lag_shift = false;
    toggle_lag = false;
    teleportshift = false;
    return true;
  }
  else
    last_choke = interfaces::client_state->choked_commands;

  return false;
}

void c_exploits::on_pre_predict( )
{
  this->update_amounts( );

  if( g_cfg.rage.enable && g_cfg.binds [ hs_b ].toggled )
  {
    if( !this->trigger_hs )
    {
      this->hs_active = true;
      this->trigger_hs = true;
    }
  }
  else
    this->trigger_hs = false;

  if( g_cfg.rage.enable && g_cfg.binds [ dt_b ].toggled )
  {
    if( !this->trigger_dt )
    {
      this->dt_active = true;
      this->trigger_dt = true;
    }
  }
  else
    this->trigger_dt = false;

  bool active = this->dt_toggled && this->dt_active || this->hs_toggled && this->hs_active;

  if( charge_ticks < amounts.recharge && active )
  {
    recharge = true;
    recharge_finish = false;
  }
}

void c_exploits::double_tap( )
{
  auto viewmodel = g_ctx.local->get_view_model( );
  if( !viewmodel )
    return;

  static bool toggle_charge = false;

  if( toggle_charge )
  {
    toggle_charge = false;
    this->charge_dt = true;
    this->reset_shift( );
    return;
  }

  static int last_choke = 0;

  if( this->charge_dt )
  {
    bool shot_finish = false;
    if( g_ctx.weapon->item_definition_index( ) == weapon_ssg08 || g_ctx.weapon->item_definition_index( ) == weapon_awp )
    {
      float shot_diff = std::abs( g_ctx.weapon->last_shot_time( ) - g_ctx.predicted_curtime );

      shot_finish = shot_diff >= 0.4f;
    }
    else
    {
      float old_time = g_ctx.predicted_curtime;

      g_ctx.predicted_curtime = math::ticks_to_time( g_ctx.local->tickbase( ) - ( ( this->amounts.dt_shift / 2 ) + 1 ) );
      shot_finish = g_utils->is_able_to_shoot( true );
      g_ctx.predicted_curtime = old_time;
    }

    if( shot_finish && !g_rage_bot->working && !last_choke )
    {
      if( !g_cfg.binds [ dt_b ].toggled )
        this->teleport = false;
      else
        this->teleport = true;

      this->dt_bullet = 0;
      this->charge_dt = false;
      this->dt_active = true;
    }
    else if( g_ctx.cmd->buttons & in_attack )
      this->dt_bullet++;
    else
      last_choke = interfaces::client_state->choked_commands;

    this->shift_tick = 0;
    return;
  }

  if( g_anti_aim->is_fake_ducking( ) || g_cfg.binds [ sw_b ].toggled )
  {
    this->dt_toggled = false;

    if( !this->dt_off )
    {
      this->stop_movement = true;

      if( this->teleport )
      {
        shift_fake_cmds( g_ctx.cmd, &first_cmd, amounts.dt_shift );
        this->teleport = false;
      }

      this->dt_off = true;
    }

    this->reset_shift( );

    return;
  }

  if( !g_cfg.binds [ dt_b ].toggled )
  {
    this->dt_toggled = false;

    if( !g_cfg.binds [ hs_b ].toggled && !dt_off )
    {
      this->stop_movement = true;

      if( teleport )
      {
        shift_fake_cmds( g_ctx.cmd, &first_cmd, amounts.dt_shift );
        this->teleport = false;
      }

      this->reset_shift( );

      this->dt_off = true;
    }
    return;
  }

  this->dt_toggled = true;
  this->dt_off = false;

  if( !this->recharge_finish )
    return;

  if( !this->teleport )
    this->teleport = true;

  int maximum_lc = amounts.dt_shift;

  if( g_ctx.weapon->is_misc_weapon( ) && !g_ctx.weapon->is_knife( ) && !g_ctx.weapon->is_taser( ) )
  {
    this->toggle_lag = false;
    this->lag_shift = false;
    this->shift_timer = 0;

    if( *g_ctx.send_packet )
      shift_fake_cmds( g_ctx.cmd, &first_cmd, maximum_lc, true );

    g_tickbase->simulation_amt = 0;
    return;
  }

  if( !g_ctx.cmd->weaponselect && g_utils->is_firing( ) )
  {
    shift_fake_cmds( g_ctx.cmd, &first_cmd, amounts.dt_shift );

    this->dt_bullet++;

    this->dt_toggled = false;
    this->dt_active = false;
    this->lag_shift = false;
    this->toggle_lag = false;
    toggle_charge = true;
    return;
  }

  bool trigger = !g_cfg.rage.anti_mrx && g_anti_aim->is_peeking( ) /*|| !( g_ctx.local->flags( ) & fl_onground )*/;

  if( trigger && g_ctx.weapon->item_definition_index( ) != weapon_revolver && !g_ctx.weapon->is_misc_weapon( ) )
  {
    if( !this->toggle_lag )
    {
      if( !this->lag_shift )
      {
        this->shift_timer = maximum_lc;
        this->lag_shift = true;
      }

      this->toggle_lag = true;
    }
  }
  else
  {
    this->lag_shift = false;
    this->toggle_lag = false;
  }

  if( this->lag_shift )
  {
    if( this->shift_timer == maximum_lc && *g_ctx.send_packet )
    {
      this->break_lc = false;
      --this->shift_timer;
    }
    else
    {
      g_exploits->shift = maximum_lc;

      if( *g_ctx.send_packet )
        shift_fake_cmds( g_ctx.cmd, &first_cmd, maximum_lc, true );

      this->break_lc = true;

      if( this->shift_timer > 0 )
        --this->shift_timer;
    }

    if( this->shift_timer <= 0 )
      this->lag_shift = false;
  }
  else
  {
    if( *g_ctx.send_packet )
      shift_fake_cmds( g_ctx.cmd, &first_cmd, maximum_lc, true );

    this->shift_timer = maximum_lc;
    this->toggle_lag = false;
    this->break_lc = true;
  }
}

void c_exploits::hide_shots( )
{
  if( g_anti_aim->is_fake_ducking( ) )
  {
    hs_toggled = false;
    hs_works = false;

    if( !hs_off )
    {
      stop_movement = true;
      shift_fake_cmds( g_ctx.cmd, &first_cmd, amounts.dt_shift );
      hs_off = true;
    }

    this->reset_shift( );
    return;
  }

  if( !g_cfg.binds [ hs_b ].toggled || g_cfg.binds [ dt_b ].toggled )
  {
    hs_toggled = false;
    hs_works = false;

    if( !g_cfg.binds [ dt_b ].toggled && !hs_off )
    {
      stop_movement = true;
      shift_fake_cmds( g_ctx.cmd, &first_cmd, amounts.dt_shift );
      this->reset_shift( );

      hs_off = true;
    }
    return;
  }

  hs_toggled = true;
  hs_off = false;
  hs_works = false;

  if( !recharge_finish )
    return;

  if( g_ctx.weapon->is_misc_weapon( ) || g_ctx.weapon->item_definition_index( ) == weapon_revolver )
    return;

  int shift_cnt = amounts.hs_shift;
  if( ( g_rage_bot->firing || g_utils->is_firing( ) ) )
  {
    if( *g_ctx.send_packet )
    {
      hs_works = true;
      shift_fake_cmds( g_ctx.cmd, &first_cmd, shift_cnt, true );

     // g_tickbase->store( g_ctx.local->tickbase( ), g_ctx.cmd->command_number, shift_cnt + 1, true );
    }
    else
      g_ctx.cmd->buttons &= ~in_attack;
  }
  else
    g_ctx.cmd->buttons &= ~in_attack;
}

void c_exploits::on_local_death( )
{
  this->trigger_dt = false;
  this->trigger_hs = false;

  this->reset_shift( );
  this->cl_move.reset( );

  this->dt_toggled = false;
  this->dt_active = false;
  this->dt_off = false;
  this->teleport = false;
  this->hs_toggled = false;
  this->hs_active = false;
  this->hs_off = false;
  this->charge_dt = false;
  this->recharge_finish = false;
  this->stop_movement = false;
  this->hs_works = false;
  this->break_lc = false;
  this->teleportshift = false;
}

inline bool is_peeking_for_exploits( )
{
  return g_anti_aim->is_peeking( );
}

void c_exploits::on_predict_start( )
{
  if( cl_move.shift )
    return;

  this->double_tap( );
  this->hide_shots( );

  if( !g_cfg.binds [ ap_b ].toggled )
    g_rage_bot->firing = false;
}

void c_exploits::on_cl_move( float sample, bool final_tick )
{
}

namespace ping_reducer
{
  __forceinline bool available( )
  {
    if( !g_ctx.in_game )
      return false;

    auto net_chan = interfaces::engine->get_net_channel_info( );
    if( !net_chan )
      return false;

    if( net_chan->is_loopback( ) )
      return false;

    if( g_exploits->recharge && !g_exploits->recharge_finish )
      return false;

    return true;
  }

  __forceinline bool should_work( )
  {
    if( !available( ) )
      return false;

    ping_data.write( );
    return true;
  }

  __forceinline void update_ping_values( bool final_tick )
  {
    if( !available( ) )
      return;

    static auto original_packet = hooker.original( &tr::engine::read_packets );

    ping_backup_t backup{ };
    backup.read( );

    original_packet( final_tick );
    ping_data.read( );

    backup.write( );
  }
}