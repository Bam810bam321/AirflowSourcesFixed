#pragma once
#include <array>
#include <stack>

#include "../config_vars.h"
#include "../../base/sdk/entity.h"
#include "../../base/global_context.h"

class c_usercmd;

namespace ping_reducer
{
  struct ping_backup_t
  {
    float curtime{ };
    float frametime{ };
    int tickcount{ };
    float cs_frametime{ };

    void read( )
    {
      curtime = interfaces::global_vars->cur_time;
      frametime = interfaces::global_vars->frame_time;
      tickcount = interfaces::global_vars->tick_count;
      cs_frametime = interfaces::client_state->frame_time;
    }

    void write( )
    {
      interfaces::global_vars->cur_time = curtime;
      interfaces::global_vars->frame_time = frametime;
      interfaces::global_vars->tick_count = tickcount;
      interfaces::client_state->frame_time = cs_frametime;
    }
  };

  inline ping_backup_t ping_data{ };

  extern bool should_work( );
  extern void update_ping_values( bool final_tick );
}

class c_tickbase
{
private:
  struct tickbase_data_t
  {
    int tickbase{ };
    int command_number{ };
    int shift_amount{ };
    int cmd_diff{ };
    bool restore_tickbase{ };
    bool restore_vars{ };
  };

public:
  tickbase_data_t data{ };

  int simulation_amt{ };
  /// <summary>
  /// get data for tickbase restoring after exploit usage
  /// </summary>
  /// <param name="tickbase"> tickbase before shift </param>
  /// <param name="cmd"> last command number when shift began </param>
  /// <param name="shift"> how many commands were shifted </param>
  /// <param name="restore"> should we restore tickbase back? </param>
  /// <param name="cmd_diff"> how many commands created after disabling shift </param>
  void store( int tickbase, int cmd, int shift, bool restore, int cmd_diff = 1 );
  void fix( int new_command_number, int& tickbase );
};

class c_exploits
{
private:
  void force_shift( c_usercmd* cmd, int amount, bool buffer = false );

public:
  c_usercmd first_cmd{ };

  bool trigger_hs{ };
  bool trigger_dt{ };

  bool dt_toggled{ };
  bool dt_active{ };
  bool dt_off{ };
  bool teleport{ };

  bool hs_toggled{ };
  bool hs_active{ };
  bool hs_off{ };
  bool charge_dt{ };
  bool recharge{ };
  bool recharge_finish{ };
  bool stop_movement{ };
  bool hs_works{ };
  bool lag_shift{ };
  bool toggle_lag{ };
  bool break_lc{ };
  bool teleportshift{ };

  // they now should be updated always on
  // based on sv_maxusrcmdprocessticks cvar
  struct
  {
    int recharge{ };
    int dt_shift{ };
    int hs_shift{ };
  } amounts;

  __forceinline void update_amounts( )
  {
    amounts.recharge = g_ctx.max_choke;
    amounts.dt_shift = g_ctx.max_choke;
    amounts.hs_shift = std::max< int >( 0, g_ctx.max_choke - 5 );
  }

  struct cl_move_t
  {
    bool shift = false;
    bool shifting = false;
    bool valid = false;
    bool no_teleport = false;
    int amount = 0;

    inline void reset( )
    {
      shift = false;
      shifting = false;
      valid = false;

      amount = 0;
    }
  } cl_move;

  int shift{ };
  int shift_timer{ };
  int charge_ticks{ };
  int shift_tick{ };
  int dt_bullet{ };

  void reset_shift( )
  {
    recharge = false;
    toggle_lag = false;
    lag_shift = false;
    shift_timer = 0;
    charge_ticks = 0;
    shift_tick = 0;
  }

  bool recharged( )
  {
    return charge_ticks >= amounts.recharge && recharge_finish;
  }

  bool enabled( )
  {
    return ( g_cfg.binds [ dt_b ].toggled || g_cfg.binds [ hs_b ].toggled ) && this->recharged( );
  }

  bool dt_enabled( )
  {
    return g_cfg.binds [ dt_b ].toggled && this->recharged( );
  }

  bool hs_enabled( )
  {
    return !g_cfg.binds [ dt_b ].toggled && g_cfg.binds [ hs_b ].toggled && this->recharged( );
  }

  int tickbase_offset( bool dt = false )
  {
    if( this->hs_enabled( ) && !dt )
      return amounts.hs_shift;

    if( dt && this->dt_enabled( ) )
      return amounts.dt_shift;

    return 0;
  }

  bool recharging( c_usercmd* cmd );

  void double_tap( );
  void hide_shots( );
  void on_local_death( );
  bool should_shift_cmd( int* new_commands, int* backup_commands, void* ecx, int slot, void* buf, int from, int to );

  void on_pre_predict( );
  void on_predict_start( );

  void on_cl_move( float sample, bool final_tick );
};