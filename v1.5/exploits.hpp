#pragma once

enum exploits_mode_t
{
	EXPLOITS_DT = 0,
	EXPLOITS_HS,
	EXPLOITS_NONE,
};

class c_user_cmd;

class c_tickbase
{
private:
	struct tickbase_data_t
	{
		int tickbase{};
		int command_number{};
		int shift_amount{};
		int cmd_diff{};
		bool restore_tickbase{};
		bool restore_vars{};
	};

public:
	tickbase_data_t data{};

	INLINE void reset()
	{
		data.tickbase = 0;
		data.command_number = 0;
		data.shift_amount = 0;
		data.cmd_diff = 0;
		data.restore_tickbase = 0;
		data.restore_vars = 0;
	}

	void store(int tickbase, int cmd, int shift, bool restore, int cmd_diff = 1);
	void fix(int new_command_number, int& tickbase);
};

class c_exploits
{
private:
	bool in_action{};
	bool available{};

	int current_mode{};

	int get_instance_mode();
	void update_exploit_mode();

public:
	bool start_fix{};
	bool shift_complete{};
	bool execute_shift{};
	bool reset_dt{};

	int dt_bullet{};
	int tick_to_shift{};
	int tick_to_shift_before{ 1 };
	int break_lc_tick{};

	struct recharge_t
	{
		bool start{};
		bool finish{};
		bool fix_tickbase{};

		int charge_ticks{};
		int last_charge_tick{};

		INLINE void reset()
		{
			start = false;
			finish = false;
			fix_tickbase = false;
			charge_ticks = 0;
			last_charge_tick = 0;
		}
	} recharge;

	struct limits_t
	{
		int recharge{};
		int double_tap{};
		int hide_shots{};

		INLINE void update()
		{
			recharge = HACKS->max_choke;
			double_tap = HACKS->max_choke - 1;
			hide_shots = std::clamp(HACKS->max_choke - 5, 0, HACKS->max_choke);
		}
	} limits;

	struct cl_move_t
	{
		bool trigger{};
		bool shifting{};
		bool complete{};

		int amount{};
		int finish_tick{};

		INLINE void reset()
		{
			trigger = false;
			shifting = false;
			complete = false;
			amount = 0;
			finish_tick = 0;
		}
	} cl_move;

	struct defensive_t
	{
		bool toggle_lag{};
		bool lag_shift{};

		int tickbase_choke{ 100 };

		INLINE void reset()
		{
			toggle_lag = false;
			lag_shift = false;
			tickbase_choke = 100;
		}
	} defensive;

	c_user_cmd first_cmd{};

	INLINE bool enabled()
	{
		return !recharge.start && recharge.finish && recharge.charge_ticks <= 0;
	}

	INLINE int tickbase_offset()
	{
		if (!enabled() || current_mode != EXPLOITS_HS)
			return 0;

		return limits.hide_shots;
	}

	INLINE int get_exploit_mode()
	{
		return current_mode;
	}

	INLINE void reset()
	{
		reset_dt = false;
		start_fix = false;
		in_action = false;
		shift_complete = false;
		execute_shift = false;

		current_mode = EXPLOITS_NONE;

		recharge.reset();
		cl_move.reset();
		defensive.reset();

		break_lc_tick = 0;
		tick_to_shift_before = 0;
		tick_to_shift = 0;
		dt_bullet = 0;
	}

	bool should_shift_cmd(int* new_commands, int* backup_commands, void* ecx, void* edx, int slot, void* buf, int from, int to);
	void shift_clmove(float accumulated_extra_samples, bool final_tick);
	bool should_recharge();
	void update_instance();
	void run();
};

#ifdef _DEBUG
inline auto TICKBASE = std::make_unique<c_tickbase>();
#else
CREATE_DUMMY_PTR(c_tickbase);
DECLARE_XORED_PTR(c_tickbase, GET_XOR_KEYUI32);

#define TICKBASE XORED_PTR(c_tickbase)
#endif

#ifdef _DEBUG
inline auto EXPLOITS = std::make_unique<c_exploits>();
#else
CREATE_DUMMY_PTR(c_exploits);
DECLARE_XORED_PTR(c_exploits, GET_XOR_KEYUI32);

#define EXPLOITS XORED_PTR(c_exploits)
#endif