#include "../../base/sdk.h"
#include "../../base/sdk/entity.h"
#include "../../base/sdk/c_usercmd.h"
#include "../../base/global_context.h"
#include "../../base/tools/threads.h"
#include "../../base/hooks/hooks.h"

#include "../features.h"
#include "../config_vars.h"

#include "../../additionals/tinyformat.h"

#include "../extra/cmd_shift.h"

void c_tickbase::store(int tickbase, int cmd, int shift, bool restore, int cmd_diff)
{
	auto& d = this->data;
	d.tickbase = tickbase;
	d.command_number = cmd;
	d.shift_amount = shift;
	d.restore_tickbase = restore;
	d.cmd_diff = cmd_diff;
}

void c_tickbase::fix(int new_command_number, int& tickbase)
{
	auto& d = this->data;
	if (d.command_number <= 0)
		return;

	auto viewmodel = g_ctx.local->get_view_model();
	if (!viewmodel)
		return;

	//printf("%d -> %d \n", d.command_number, new_command_number);

	if (d.command_number == new_command_number)
	{
		viewmodel->anim_time() -= math::ticks_to_time(d.shift_amount + interfaces::global_vars->sim_ticks_this_frame);
		tickbase = d.tickbase - d.shift_amount + interfaces::global_vars->sim_ticks_this_frame;

	//	interfaces::global_vars->cur_time = math::ticks_to_time(tickbase);

		//g_ctx.tick_base = tickbase;
	}

	if (d.restore_tickbase && d.command_number + d.cmd_diff == new_command_number)
	{
		viewmodel->anim_time() += math::ticks_to_time(d.shift_amount - interfaces::global_vars->sim_ticks_this_frame);
		tickbase += d.shift_amount - interfaces::global_vars->sim_ticks_this_frame;

	//	interfaces::global_vars->cur_time = math::ticks_to_time(tickbase);

		//g_ctx.tick_base = tickbase;
	}
}

int c_exploits::get_instance_mode()
{
	if (g_anti_aim->is_fake_ducking() || g_cfg.binds[fd_b].toggled)
		return exploits_disabled;

	if (g_cfg.binds[dt_b].toggled)
		return exploits_dt;

	if (g_cfg.binds[hs_b].toggled)
		return exploits_hs;

	return exploits_disabled;
}

bool c_exploits::should_recharge()
{
	if (!this->available)
		return false;

	auto& recharge = this->recharge;
	static int choke{};

	if (recharge.start && !choke)
	{
		if (recharge.charge_ticks <= 0)
		{
			recharge.start = false;
			recharge.finish = true;
			return false;
		}

		recharge.finish = false;
		--recharge.charge_ticks;
		return true;
	}
	else
		choke = interfaces::client_state->choked_commands;

	return false;
}

void c_exploits::update_exploit_mode()
{
	if (!this->available)
	{
		this->recharge.reset();
		return;
	}

	auto instance_mode = this->get_instance_mode();
	if (this->current_mode != instance_mode)
	{
		auto& recharge = this->recharge;
		if (instance_mode == exploits_disabled)
		{
			if (!this->in_action && this->enabled())
			{
				//cmd_shift::shift_predicted(g_ctx.cmd, &this->first_cmd, this->limits.double_tap);

				auto& cl_move = this->cl_move;
				cl_move.trigger = true;
				cl_move.shifting = false;
				cl_move.complete = false;
				cl_move.amount = this->limits.double_tap - 1;
			}

			recharge.reset();
			this->reset_dt = false;

			this->tick_to_shift_before = 0;
			this->dt_bullet = 0;
			this->current_mode = instance_mode;
		}
		else
		{
			if (!recharge.start && !recharge.finish)
			{
				recharge.start = true;
				recharge.finish = false;
				recharge.charge_ticks = this->limits.recharge;
				recharge.fix_tickbase = true;

				this->in_action = false;
				this->reset_dt = false;
				this->dt_bullet = 0;
			}

			this->current_mode = instance_mode;
		}
	}
}

inline bool is_peeking_for_exploits()
{
	return g_anti_aim->is_peeking();
}

void c_exploits::update_instance()
{
	this->available = !(g_ctx.local->flags() & fl_frozen) && !g_ctx.local->gun_game_immunity();

	auto threaded_peeking = g_thread_pool->add_task(is_peeking_for_exploits);
	auto result = std::any_cast<bool>(g_thread_pool->wait_result(threaded_peeking));

	g_ctx.current_shift_amount = 0;
	g_ctx.predictive_point_for_dt = result;

	this->limits.update();
	this->update_exploit_mode();

	if (!g_cfg.binds[ap_b].toggled)
		g_rage_bot->firing = false;
}

void c_exploits::run()
{
	if (this->current_mode == exploits_disabled || !this->enabled())
		return;

	auto& recharge = this->recharge;

	if (!cmd_shift::shifting && recharge.fix_tickbase)
	{
		g_tickbase->store(g_ctx.local->tickbase(), g_ctx.cmd->command_number, this->limits.double_tap + 1, false);

		recharge.fix_tickbase = false;
		return;
	}

	switch (this->current_mode)
	{
	case exploits_dt:
	{
		if (this->reset_dt)
		{
			auto& cl_move = this->cl_move;

			bool shot_finish = false;
			if (g_ctx.weapon->item_definition_index() == weapon_ssg08 || g_ctx.weapon->item_definition_index() == weapon_awp)
			{
				float shot_diff = std::abs(g_ctx.weapon->last_shot_time() - g_ctx.predicted_curtime);
				shot_finish = shot_diff >= 0.4f;
			}
			else 
			{
				float old_time = g_ctx.predicted_curtime;

				if ((g_ctx.weapon->is_pistols() && g_ctx.weapon->item_definition_index() != weapon_cz75a) || g_ctx.weapon->is_heavy_pistols() || g_ctx.weapon->is_sniper())
					g_ctx.predicted_curtime = math::ticks_to_time(g_ctx.local->tickbase() - ((this->limits.double_tap / 2) + 1));
				else
					g_ctx.predicted_curtime -= math::ticks_to_time(this->limits.double_tap);

				shot_finish = g_utils->is_able_to_shoot(true);
				g_ctx.predicted_curtime = old_time;
			}

			static int choke{};
			if (!cmd_shift::shifting && shot_finish && !g_rage_bot->working && !choke)
			{
				recharge.start = true;
				recharge.finish = false;
				recharge.charge_ticks = this->limits.recharge;

				this->reset_dt = false;
				this->in_action = false;
			}
			else if (g_ctx.cmd->buttons & in_attack)
				this->dt_bullet++;
			else
				choke = interfaces::client_state->choked_commands;

			return;
		}

	 	auto& defensive = this->defensive;
		auto max_shift_amount = this->limits.double_tap;
		auto misc_weapon = g_ctx.weapon->is_misc_weapon() && !g_ctx.weapon->is_knife() && !g_ctx.weapon->is_taser();
		if (!g_ctx.weapon->is_grenade() && !misc_weapon && (g_utils->is_firing() || g_rage_bot->firing))
			this->execute_shift = true;

		if (this->execute_shift)
		{
		/*	auto& cl_move = this->cl_move;
			cl_move.trigger = true;
			cl_move.shifting = false;
			cl_move.complete = false;
			cl_move.amount = this->limits.double_tap - 1;*/

			cmd_shift::shift_predicted(g_ctx.cmd, &this->first_cmd, max_shift_amount);

			this->reset_dt = true;
			this->in_action = true;
			this->execute_shift = false;
			this->dt_bullet++;

			defensive.tickbase_choke = 100;

			*g_ctx.send_packet = true;
			return;
		}

		auto start_defensive = !misc_weapon && g_ctx.weapon->item_definition_index() != weapon_revolver
			&& (g_ctx.predictive_point_for_dt || g_cfg.rage.air_defensive && (!(g_ctx.local->flags() & fl_onground)));

		if (start_defensive)
		{
			if (defensive.tickbase_choke == 100)
			{
				this->tick_to_shift_before = max_shift_amount;
				this->tick_to_shift = max_shift_amount;
				defensive.tickbase_choke = 0;
			}
			else
			{
				if (defensive.tickbase_choke == 0)
				{
					this->tick_to_shift_before = 0;
					this->tick_to_shift = 0;

					*g_ctx.send_packet = true;

					g_tickbase->store(g_ctx.local->tickbase(), g_ctx.cmd->command_number, -max_shift_amount + 1, false);

					++defensive.tickbase_choke;
				}
				else
				{
					this->tick_to_shift_before = max_shift_amount;
					this->tick_to_shift = max_shift_amount;

					if (defensive.tickbase_choke == 1 /*&& *g_ctx.send_packet*/ && this->tick_to_shift && this->shift_complete)
					{
						*g_ctx.send_packet = true;

						g_tickbase->store(g_ctx.local->tickbase(), interfaces::client_state->last_outgoing_command + 1, max_shift_amount + 1, false);

						this->shift_complete = false;
					}

					if (++defensive.tickbase_choke > max_shift_amount + 1)
						defensive.tickbase_choke = 0;
				}
			}
		}
		else
		{
			g_ctx.current_shift_amount = 0;
			defensive.tickbase_choke = 100;
			this->tick_to_shift = max_shift_amount;
			this->tick_to_shift_before = max_shift_amount;
		}

		this->in_action = false;
	}
	break;
	case exploits_hs:
	{
		this->tick_to_shift_before = this->limits.double_tap;

		if (g_ctx.weapon->is_misc_weapon() || g_ctx.weapon->item_definition_index() == weapon_revolver)
		{
			this->in_action = false;
			return;
		}

		if ((g_rage_bot->firing || g_utils->is_firing()))
		{
			if (*g_ctx.send_packet)
			{
				this->in_action = true;
				this->tick_to_shift = this->limits.hide_shots;

				g_tickbase->store(g_ctx.local->tickbase(), g_ctx.cmd->command_number, this->limits.hide_shots + 1, true);
			}
			else
			{
				g_ctx.cmd->buttons &= ~in_attack;
				this->in_action = false;
			}
		}
		else
		{
			g_ctx.cmd->buttons &= ~in_attack;
			this->in_action = false;
		}
	}
	break;
	}
}

void c_exploits::shift_clmove(float accumulated_extra_samples, bool final_tick)
{
	if (!g_ctx.is_alive)
		return;

	auto& cl_move = this->cl_move;
	if (!cl_move.trigger)
		return;

	static auto original = hooker.original(&tr::engine::cl_move);

	cl_move.complete = false;

	while (cl_move.amount >= 0)
	{
		if (*g_ctx.send_packet && cl_move.amount >= this->limits.double_tap)
			*g_ctx.send_packet = false;

		g_engine_prediction->update();

		cl_move.shifting = true;
		original(0.f, cl_move.amount <= 0);

		cl_move.amount--;
	}

	cl_move.trigger = false;
	cl_move.shifting = false;
	cl_move.complete = true;
}

void write_user_cmd(void* buf, c_usercmd* in, c_usercmd* out)
{
	__asm 
	{
		mov     ecx, buf
		mov     edx, in
		push    out
		call    func_ptrs::write_user_cmd
		add     esp, 4
	}
}

bool c_exploits::should_shift_cmd(int* new_commands, int* backup_commands, void* ecx, void* edx, int slot, void* buf, int from, int to)
{
	static auto original = vtables[vmt_client].original<decltype(&tr::client::write_usercmd_to_delta_buffer)>(xor_int(24));

	auto newcmds = *new_commands;
	auto shift_amount = std::clamp(this->tick_to_shift, 1, this->limits.recharge);

	this->shift_complete = false;
	this->tick_to_shift = 0;
	*backup_commands = 0;

	auto choked_modifier = newcmds + shift_amount;

	if (choked_modifier > 62)
		choked_modifier = 62;

	*new_commands = choked_modifier;

	auto final_from = -1;
	auto next_cmdnr = interfaces::client_state->choked_commands + interfaces::client_state->last_outgoing_command + 1;
	auto final_to = next_cmdnr - newcmds + 1;

	if (final_to <= next_cmdnr) 
	{
		while (original(ecx, edx, slot, buf, final_from, final_to, true)) 
		{
			final_from = final_to++;

			if (final_to > next_cmdnr)
				goto next_cmd;
		}

		return false;
	}
next_cmd:

	auto user_cmd = interfaces::input->get_user_cmd(final_from);

	if (!user_cmd)
		return true;

	c_usercmd to_cmd;
	c_usercmd from_cmd;

	from_cmd = *user_cmd;
	to_cmd = from_cmd;

	++to_cmd.command_number;
	to_cmd.tickcount = INT_MAX;
	do 
	{
		write_user_cmd(buf, &to_cmd, &from_cmd);

		++to_cmd.command_number;
		shift_amount--;
	} while (shift_amount > 0);

	this->shift_complete = true;

	return true;
}