#pragma once
#include <array>
#include <stack>

#include "../config_vars.h"
#include "../../base/sdk/entity.h"
#include "../../base/global_context.h"

enum exploits_mode_t
{
	exploits_dt = 0,
	exploits_hs,
	exploits_disabled,
};

class c_usercmd;

class c_tickbase
{
private:
	struct tickbase_data_t
	{
		int tickbase{};
		int command_number{};
		int shift_amount{};
		int cmd_diff{};
		bool restore_tickbase{};
		bool restore_vars{};
	};

public:
	tickbase_data_t data{};

	void store(int tickbase, int cmd, int shift, bool restore, int cmd_diff = 1);
	void fix(int new_command_number, int& tickbase);
};

class c_exploits
{
private:
	bool reset_dt{};
	bool in_action{};
	bool available{};

	int current_mode{};

	int get_instance_mode();
	void update_exploit_mode();

public:
	bool start_fix{};
	bool shift_complete{};
	bool execute_shift{};
	int dt_bullet{};
	int tick_to_shift{};
	int tick_to_shift_before{1};

	struct recharge_t
	{
		bool start{};
		bool finish{};
		bool fix_tickbase{};

		int charge_ticks{};

		inline void reset()
		{
			this->start = false;
			this->finish = false;
			this->fix_tickbase = false;
			this->charge_ticks = 0;

			g_ctx.current_shift_amount = 0;
		}
	} recharge;

	struct limits_t
	{
		int recharge{};
		int double_tap{};
		int hide_shots{};

		inline void update()
		{
			this->recharge = g_ctx.max_choke;
			this->double_tap = g_ctx.max_choke;
			this->hide_shots = std::clamp(g_ctx.max_choke - 5, 0, g_ctx.max_choke);
		}
	} limits;

	struct cl_move_t
	{
		bool trigger{};
		bool shifting{};
		bool complete{};

		int amount{};

		inline void reset()
		{
			this->trigger = false;
			this->shifting = false;
			this->complete = false;
			this->amount = 0;

			g_ctx.current_shift_amount = 0; 
		}
	} cl_move;

	struct defensive_t
	{
		bool toggle_lag{};
		bool lag_shift{};

		int tickbase_choke{100};

		inline void reset()
		{
			this->toggle_lag = false;
			this->lag_shift = false;
			this->tickbase_choke = 100;
		}
	} defensive;

	c_usercmd first_cmd{};

	inline bool enabled()
	{
		auto& recharge = this->recharge;
		return !recharge.start && recharge.finish && recharge.charge_ticks <= 0;
	}

	inline int tickbase_offset()
	{
		if (!this->enabled() || this->current_mode != exploits_hs)
			return 0;

		return this->limits.hide_shots;
	}

	inline int get_exploit_mode()
	{
		return this->current_mode;
	}

	inline void reset()
	{
		this->reset_dt = false;
		this->start_fix = false;
		this->in_action = false;
		this->shift_complete = false;
		this->execute_shift = false;

		this->current_mode = exploits_disabled;

		this->recharge.reset();
		this->cl_move.reset();
		this->defensive.reset();

		this->tick_to_shift_before = 0;
		this->tick_to_shift = 0;
		this->dt_bullet = 0;

		g_ctx.current_shift_amount = 0; 
	}

	bool should_shift_cmd(int* new_commands, int* backup_commands, void* ecx, void* edx, int slot, void* buf, int from, int to);
	void shift_clmove(float accumulated_extra_samples, bool final_tick);
	bool should_recharge();
	void update_instance();
	void run();
};